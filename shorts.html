<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Portal Escape Challenge</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <style>
        body {
            margin: 0;
            background: #000000;
            overflow: hidden;
            touch-action: manipulation;
            font-family: 'Arial Black', Arial, sans-serif;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        #prompt {
            position: absolute;
            top: 4vh;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: min(6vw, 36px);
            text-align: center;
            text-shadow: 0 0 10px #00ff7f;
            width: 90%;
            z-index: 100;
            animation: text-glow 2s infinite alternate;
            pointer-events: none;
            margin-bottom: 5vh;
        }
        #winner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: min(10vw, 72px);
            text-align: center;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
            width: 90%;
            text-transform: uppercase;
            font-weight: 900;
            transition: all 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            text-shadow: 0 0 20px currentColor;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 20px;
            border: 3px solid currentColor;
        }
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            background: rgba(0,255,127,0.3);
            color: white;
            border: 3px solid #00ff7f;
            border-radius: 15px;
            font-size: min(6vw, 24px);
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff7f;
            box-shadow: 0 0 15px rgba(0,255,127,0.5);
        }
        #startButton:hover {
            background: rgba(0,255,127,0.5);
            transform: translate(-50%, -50%) scale(1.05);
        }
        .gap-container {
            position: absolute;
            bottom: 5vh;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            gap: 2vh;
            z-index: 5;
        }
        .gap {
            width: 15vw;
            max-width: 80px;
            height: 0.5vh;
            border: 2px solid #00ff7f;
            border-radius: 5px;
            box-shadow: 0 0 15px #00ff7f,
                        inset 0 0 10px #00ff7f;
            animation: neon-flicker 2s infinite alternate;
        }
        .arrow {
            width: 0;
            height: 0;
            border-left: 3vw solid transparent;
            border-right: 3vw solid transparent;
            border-bottom: 5vh solid #00ff7f;
            filter: drop-shadow(0 0 5px #00ff7f);
            animation: bounce 0.8s infinite alternate;
        }
        @keyframes neon-flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                box-shadow: 0 0 15px #00ff7f,
                            inset 0 0 10px #00ff7f;
            }
            20%, 24%, 55% {
                box-shadow: 0 0 5px #00ff7f,
                            inset 0 0 3px #00ff7f;
            }
        }
        @keyframes bounce {
            0% { transform: translateY(0); }
            100% { transform: translateY(-1vh); }
        }
        @keyframes text-glow {
            0% { text-shadow: 0 0 10px #00ff7f; }
            100% { text-shadow: 0 0 20px #00ff7f, 0 0 30px #00ff7f; }
        }
        @keyframes winner-pop {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
                text-shadow: 0 0 0px currentColor;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 1;
                text-shadow: 0 0 30px currentColor;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                text-shadow: 0 0 20px currentColor;
            }
        }
        /* Supercharged Countdown Styles */
        #countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        #countdown-text {
            font-size: min(30vw, 200px);
            font-weight: 900;
            color: white;
            text-shadow: 0 0 20px #00ff7f, 
                         0 0 40px #00ff7f,
                         0 0 80px #00ff7f;
            transform: scale(0.1);
            opacity: 0;
        }
        @keyframes countdown-pop {
            0% { 
                transform: scale(0.1) rotate(-20deg);
                opacity: 0;
                text-shadow: 0 0 0px #00ff7f;
            }
            20% {
                transform: scale(1.5) rotate(5deg);
                opacity: 1;
                text-shadow: 0 0 50px #00ff7f;
            }
            40% {
                transform: scale(0.9) rotate(0deg);
            }
            60% {
                transform: scale(1.1) rotate(0deg);
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
                text-shadow: 0 0 20px #00ff7f;
            }
        }
        @keyframes countdown-exit {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="prompt">Which ball will escape first???</div>
    <canvas id="gameCanvas"></canvas>
    <div class="gap-container">
        <div class="arrow"></div>
        <div class="gap"></div>
    </div>
    <div id="winner"></div>
    <button id="startButton">START CHALLENGE</button>
    
    <!-- Countdown overlay -->
    <div id="countdown-overlay">
        <div id="countdown-text">3</div>
    </div>
    
    <!-- Audio elements -->
    <audio id="wallCollisionSound" preload="auto">
        <source src="col.mp3" type="audio/mpeg">
    </audio>
    <audio id="ballCollisionSound" preload="auto">
        <source src="col.mp3" type="audio/mpeg">
    </audio>
    <audio id="countdownSound" preload="auto">
        <source src="col.mp3" type="audio/mpeg">
    </audio>
    <audio id="goSound" preload="auto">
        <source src="col.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const winnerElement = document.getElementById('winner');
        const startButton = document.getElementById('startButton');
        const promptElement = document.getElementById('prompt');
        const countdownOverlay = document.getElementById('countdown-overlay');
        const countdownText = document.getElementById('countdown-text');
        
        // Audio setup
        const wallCollisionSound = document.getElementById('wallCollisionSound');
        const ballCollisionSound = document.getElementById('ballCollisionSound');
        const countdownSound = document.getElementById('countdownSound');
        const goSound = document.getElementById('goSound');
        
        // Set volumes
        [wallCollisionSound, ballCollisionSound, countdownSound, goSound].forEach(sound => {
            sound.volume = 0.3;
        });
        
        // Audio context resume function for mobile
        function setupAudio() {
            if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                const context = new (AudioContext || webkitAudioContext)();
                const buffer = context.createBuffer(1, 1, 22050);
                const source = context.createBufferSource();
                source.buffer = buffer;
                source.connect(context.destination);
                source.start();
                document.removeEventListener('click', setupAudio);
            }
        }
        document.addEventListener('click', setupAudio);
        
        // Modified playSound function to ensure audio works
        function playSound(sound) {
            try {
                sound.currentTime = 0;
                sound.playbackRate = 0.9 + Math.random() * 0.2;
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => console.log("Audio play prevented:", e));
                }
            } catch(e) {
                console.log("Audio error:", e);
            }
        }

        // Mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Game parameters with your exact gradient colors
        const BALL_COLORS = [
            'linear-gradient(#FF0000, #CC0000)',
            'linear-gradient(#FFFF00, #FFCC00)',
            'linear-gradient(#0000FF, #0000AA)'
        ];
        const BALL_NAMES = ['RED', 'YELLOW', 'BLUE'];
        const PORTAL_COLORS = ['#FF4081', '#00BCD4'];
        const BOX_PADDING = isMobile ? 40 : 80;
        const GAP_WIDTH = isMobile ? 60 : 80;
        const INITIAL_SPEED = isMobile ? 3 : 4;
        const SPEED_BOOST = 0.2;
        const MAX_SPEED = isMobile ? 8 : 12;
        
        // Game state
        let balls = [];
        let portals = [];
        let boundaries = [];
        let gameActive = false;
        let animationId;
        let gameStartTime = 0;
        const MIN_TIME_BEFORE_ESCAPE = 2000;
        
        // Supercharged Countdown function
        function startCountdown() {
            // First make sure button is completely gone
            startButton.style.opacity = 0;
            startButton.style.pointerEvents = 'none';
            
            // Wait for button to fully disappear before starting countdown
            setTimeout(() => {
                startButton.style.display = 'none';
                countdownOverlay.style.opacity = 1;
                
                let count = 3;
                
                const showNumber = () => {
                    countdownText.textContent = count;
                    
                    // Reset animation
                    countdownText.style.animation = '';
                    void countdownText.offsetWidth; // Trigger reflow
                    
                    // Apply animation
                    countdownText.style.animation = 'countdown-pop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards';
                    
                    // Play sound with different pitch for each number
                    countdownSound.playbackRate = 0.8 + (count * 0.1);
                    playSound(countdownSound);
                    
                    if(count === 0) {
                        countdownText.textContent = "GO!";
                        countdownText.style.animation = 'countdown-pop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards';
                        playSound(goSound);
                        
                        setTimeout(() => {
                            countdownText.style.animation = 'countdown-exit 0.5s forwards';
                            setTimeout(() => {
                                countdownOverlay.style.opacity = 0;
                                startGame();
                            }, 500);
                        }, 800);
                    } else {
                        setTimeout(showNumber, 1000);
                    }
                    
                    count--;
                };
                
                // Start the countdown sequence
                showNumber();
            }, 300); // Matches the button fade-out transition time
        }

        function startGame() {
            initGame();
            gameLoop();
        }
        
        // Initialize game
        function initGame() {
            gameActive = true;
            gameStartTime = Date.now();
            winnerElement.style.opacity = 0;
            promptElement.style.display = 'block';
            
            // Create boundaries
            boundaries = [
                { x1: BOX_PADDING, y1: BOX_PADDING, x2: canvas.width - BOX_PADDING, y2: BOX_PADDING },
                { x1: canvas.width - BOX_PADDING, y1: BOX_PADDING, x2: canvas.width - BOX_PADDING, y2: canvas.height - BOX_PADDING },
                { x1: BOX_PADDING, y1: canvas.height - BOX_PADDING, x2: canvas.width/2 - GAP_WIDTH/2, y2: canvas.height - BOX_PADDING },
                { x1: canvas.width/2 + GAP_WIDTH/2, y1: canvas.height - BOX_PADDING, x2: canvas.width - BOX_PADDING, y2: canvas.height - BOX_PADDING },
                { x1: BOX_PADDING, y1: BOX_PADDING, x2: BOX_PADDING, y2: canvas.height - BOX_PADDING }
            ];
            
            // Create portals
            portals = [
                { 
                    x: canvas.width * 0.3,
                    y: canvas.height * 0.5,
                    radius: isMobile ? 40 : 50,
                    minRadius: isMobile ? 30 : 40,
                    maxRadius: isMobile ? 50 : 60,
                    pulseSpeed: 0.03,
                    pulsePhase: 0,
                    rotation: 0,
                    rotationSpeed: 0.01,
                    color: PORTAL_COLORS[0],
                    secondaryColor: '#FF5252'
                },
                { 
                    x: canvas.width * 0.7,
                    y: canvas.height * 0.5,
                    radius: isMobile ? 40 : 50,
                    minRadius: isMobile ? 30 : 40,
                    maxRadius: isMobile ? 50 : 60,
                    pulseSpeed: 0.03,
                    pulsePhase: Math.PI,
                    rotation: 0,
                    rotationSpeed: -0.01,
                    color: PORTAL_COLORS[1],
                    secondaryColor: '#2196F3'
                }
            ];
            
            // Create balls with your exact gradient colors
            balls = [
                { 
                    x: canvas.width * 0.25,
                    y: canvas.height * 0.2,
                    radius: isMobile ? 10 : 12,
                    color: BALL_COLORS[0],
                    name: BALL_NAMES[0],
                    vx: (Math.random() - 0.5) * INITIAL_SPEED * 1.5,
                    vy: Math.random() * INITIAL_SPEED * 0.5,
                    trail: [],
                    escaped: false,
                    canEscape: false
                },
                { 
                    x: canvas.width * 0.5,
                    y: canvas.height * 0.2,
                    radius: isMobile ? 10 : 12,
                    color: BALL_COLORS[1],
                    name: BALL_NAMES[1],
                    vx: (Math.random() - 0.5) * INITIAL_SPEED * 1.5,
                    vy: Math.random() * INITIAL_SPEED * 0.5,
                    trail: [],
                    escaped: false,
                    canEscape: false
                },
                { 
                    x: canvas.width * 0.75,
                    y: canvas.height * 0.2,
                    radius: isMobile ? 10 : 12,
                    color: BALL_COLORS[2],
                    name: BALL_NAMES[2],
                    vx: (Math.random() - 0.5) * INITIAL_SPEED * 1.5,
                    vy: Math.random() * INITIAL_SPEED * 0.5,
                    trail: [],
                    escaped: false,
                    canEscape: false
                }
            ];
        }
        
        // Update game state
        function update() {
            if (!gameActive) return;
            
            const currentTime = Date.now();
            const timeSinceStart = currentTime - gameStartTime;
            
            if (timeSinceStart > MIN_TIME_BEFORE_ESCAPE) {
                balls.forEach(ball => {
                    ball.canEscape = true;
                });
            }
            
            balls.forEach(ball => {
                if (ball.escaped) return;
                
                ball.trail.push({ x: ball.x, y: ball.y });
                if (ball.trail.length > 15) ball.trail.shift();
                
                ball.x += ball.vx;
                ball.y += ball.vy;
                
                boundaries.forEach(wall => {
                    if (wall.y1 === canvas.height - BOX_PADDING && 
                        ball.x > canvas.width/2 - GAP_WIDTH/2 && 
                        ball.x < canvas.width/2 + GAP_WIDTH/2) return;
                    
                    const closestX = Math.max(wall.x1, Math.min(ball.x, wall.x2));
                    const closestY = Math.max(wall.y1, Math.min(ball.y, wall.y2));
                    const dx = ball.x - closestX;
                    const dy = ball.y - closestY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < ball.radius) {
                        playSound(wallCollisionSound);
                        const nx = dx / distance;
                        const ny = dy / distance;
                        const dotProduct = ball.vx * nx + ball.vy * ny;
                        ball.vx -= 2 * dotProduct * nx;
                        ball.vy -= 2 * dotProduct * ny;
                        const overlap = ball.radius - distance;
                        ball.x += nx * overlap;
                        ball.y += ny * overlap;
                    }
                });
                
                for (let i = 0; i < balls.length; i++) {
                    for (let j = i + 1; j < balls.length; j++) {
                        const ball1 = balls[i];
                        const ball2 = balls[j];
                        
                        if (ball1.escaped || ball2.escaped) continue;
                        
                        const dx = ball2.x - ball1.x;
                        const dy = ball2.y - ball1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < ball1.radius + ball2.radius) {
                            playSound(ballCollisionSound);
                            const nx = dx / distance;
                            const ny = dy / distance;
                            
                            const tx = -ny;
                            const ty = nx;
                            
                            const dpTan1 = ball1.vx * tx + ball1.vy * ty;
                            const dpTan2 = ball2.vx * tx + ball2.vy * ty;
                            
                            const dpNorm1 = ball1.vx * nx + ball1.vy * ny;
                            const dpNorm2 = ball2.vx * nx + ball2.vy * ny;
                            
                            const m1 = dpNorm1;
                            const m2 = dpNorm2;
                            
                            ball1.vx = tx * dpTan1 + nx * m2;
                            ball1.vy = ty * dpTan1 + ny * m2;
                            ball2.vx = tx * dpTan2 + nx * m1;
                            ball2.vy = ty * dpTan2 + ny * m1;
                            
                            const overlap = (ball1.radius + ball2.radius - distance) / 2;
                            ball1.x -= nx * overlap;
                            ball1.y -= ny * overlap;
                            ball2.x += nx * overlap;
                            ball2.y += ny * overlap;
                        }
                    }
                }
                
                portals.forEach(portal => {
                    const currentRadius = portal.minRadius + 
                        (Math.sin(portal.pulsePhase) * 0.5 + 0.5) * 
                        (portal.maxRadius - portal.minRadius);
                    
                    const dx = ball.x - portal.x;
                    const dy = ball.y - portal.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < currentRadius + ball.radius) {
                        const tx = -dy / distance;
                        const ty = dx / distance;
                        ball.vx += tx * SPEED_BOOST * Math.sign(portal.rotationSpeed);
                        ball.vy += ty * SPEED_BOOST * Math.sign(portal.rotationSpeed);
                        
                        const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                        if (speed > MAX_SPEED) {
                            ball.vx = ball.vx / speed * MAX_SPEED;
                            ball.vy = ball.vy / speed * MAX_SPEED;
                        }
                    }
                });
                
                if (ball.canEscape && 
                    ball.y > canvas.height - BOX_PADDING + ball.radius && 
                    ball.x > canvas.width/2 - GAP_WIDTH/2 && 
                    ball.x < canvas.width/2 + GAP_WIDTH/2) {
                    ball.escaped = true;
                    declareWinner(ball);
                }
            });
            
            portals.forEach(portal => {
                portal.rotation += portal.rotationSpeed;
                portal.pulsePhase += portal.pulseSpeed;
            });
        }
        
        // Draw vortex effect
        function drawVortex(portal) {
            const currentRadius = portal.minRadius + 
                (Math.sin(portal.pulsePhase) * 0.5 + 0.5) * 
                (portal.maxRadius - portal.minRadius);
            
            ctx.save();
            ctx.translate(portal.x, portal.y);
            ctx.rotate(portal.rotation);
            
            const spiralCount = 3;
            const segments = 20;
            
            for (let s = 0; s < spiralCount; s++) {
                const spiralOffset = (s / spiralCount) * Math.PI * 2;
                ctx.beginPath();
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const r = currentRadius * 0.4 * t;
                    const angle = spiralOffset + t * Math.PI * 4;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = portal.secondaryColor;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            ctx.restore();
        }
        
        // Create gradient for balls
        function createBallGradient(ctx, ball) {
            const gradient = ctx.createRadialGradient(
                ball.x - ball.radius * 0.3,
                ball.y - ball.radius * 0.3,
                0,
                ball.x,
                ball.y,
                ball.radius
            );
            
            if (ball.color.includes('#FF0000')) {
                // Red gradient
                gradient.addColorStop(0, '#FF0000');
                gradient.addColorStop(1, '#CC0000');
            } else if (ball.color.includes('#FFFF00')) {
                // Yellow gradient
                gradient.addColorStop(0, '#FFFF00');
                gradient.addColorStop(1, '#FFCC00');
            } else {
                // Blue gradient
                gradient.addColorStop(0, '#0000FF');
                gradient.addColorStop(1, '#0000AA');
            }
            
            return gradient;
        }
        
        // Create celebration effects
        function createCelebration(color) {
            let confettiColor;
            if (color.includes('FF0000')) confettiColor = '#FF0000';
            else if (color.includes('FFFF00')) confettiColor = '#FFFF00';
            else confettiColor = '#0000FF';
            
            confetti({
                particleCount: 150,
                spread: 90,
                origin: { y: 0.6 },
                colors: [confettiColor, '#ffffff'],
                shapes: ['circle', 'square'],
                scalar: isMobile ? 0.8 : 1
            });
            
            setTimeout(() => {
                confetti({
                    particleCount: 100,
                    angle: 60,
                    spread: 70,
                    origin: { x: 0, y: 0.7 },
                    colors: [confettiColor]
                });
                confetti({
                    particleCount: 100,
                    angle: 120,
                    spread: 70,
                    origin: { x: 1, y: 0.7 },
                    colors: [confettiColor]
                });
            }, 300);
        }
        
        // Declare winner
        function declareWinner(ball) {
            gameActive = false;
            promptElement.style.display = 'none';
            
            winnerElement.textContent = `${ball.name} WINS!`;
            
            // Set winner text color based on ball color
            if (ball.color.includes('FF0000')) {
                winnerElement.style.color = '#FF0000';
            } else if (ball.color.includes('FFFF00')) {
                winnerElement.style.color = '#FFFF00';
            } else {
                winnerElement.style.color = '#0000FF';
            }
            
            winnerElement.style.opacity = 1;
            winnerElement.style.animation = 'winner-pop 0.8s forwards';
            winnerElement.style.borderColor = winnerElement.style.color;
            
            createCelebration(ball.color);
            
            setTimeout(() => {
                winnerElement.style.opacity = 0;
                winnerElement.style.animation = '';
                initGame();
            }, 4000);
        }
        
        // Render game
        function render() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            boundaries.forEach(wall => {
                ctx.beginPath();
                ctx.moveTo(wall.x1, wall.y1);
                ctx.lineTo(wall.x2, wall.y2);
                ctx.stroke();
            });
            
            portals.forEach(portal => {
                const currentRadius = portal.minRadius + 
                    (Math.sin(portal.pulsePhase) * 0.5 + 0.5) * 
                    (portal.maxRadius - portal.minRadius);
                
                const gradient = ctx.createRadialGradient(
                    portal.x, portal.y, currentRadius * 0.7,
                    portal.x, portal.y, currentRadius * 1.3
                );
                gradient.addColorStop(0, portal.color + '00');
                gradient.addColorStop(0.5, portal.color + '40');
                gradient.addColorStop(1, portal.color + '00');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(portal.x, portal.y, currentRadius * 1.3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(portal.x, portal.y, currentRadius, 0, Math.PI * 2);
                ctx.strokeStyle = portal.color;
                ctx.lineWidth = 4;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(portal.x, portal.y, currentRadius * 0.4, 0, Math.PI * 2);
                ctx.strokeStyle = portal.secondaryColor;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                drawVortex(portal);
            });
            
            balls.forEach(ball => {
                // Draw trail (semi-transparent)
                for (let i = 0; i < ball.trail.length; i++) {
                    const alpha = (i + 1) / ball.trail.length * 0.6;
                    ctx.beginPath();
                    ctx.arc(ball.trail[i].x, ball.trail[i].y, ball.radius, 0, Math.PI * 2);
                    
                    // Trail uses solid color version of gradient
                    if (ball.color.includes('FF0000')) {
                        ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                    } else if (ball.color.includes('FFFF00')) {
                        ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                    } else {
                        ctx.fillStyle = `rgba(0, 0, 255, ${alpha})`;
                    }
                    ctx.fill();
                }
                
                // Draw main ball with gradient
                const gradient = createBallGradient(ctx, ball);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Add highlight
                const highlight = ctx.createRadialGradient(
                    ball.x - ball.radius * 0.3,
                    ball.y - ball.radius * 0.3,
                    ball.radius * 0.1,
                    ball.x - ball.radius * 0.3,
                    ball.y - ball.radius * 0.3,
                    ball.radius * 0.4
                );
                highlight.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                highlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = highlight;
                ctx.beginPath();
                ctx.arc(
                    ball.x - ball.radius * 0.3,
                    ball.y - ball.radius * 0.3,
                    ball.radius * 0.4,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            });
        }
        
        // Animation loop
        function gameLoop() {
            update();
            render();
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // Handle start button
        startButton.addEventListener('click', () => {
            startButton.style.transform = 'translate(-50%, -50%) scale(0.9)';
            setTimeout(() => {
                startButton.style.transform = 'translate(-50%, -50%) scale(1)';
                setTimeout(() => {
                    startCountdown();
                }, 200);
            }, 100);
        });
        
        // Handle resize
        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', handleResize);
        handleResize();
    </script>
</body>
</html>